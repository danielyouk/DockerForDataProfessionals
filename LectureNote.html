<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lecturenote</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="LectureNote_files/libs/clipboard/clipboard.min.js"></script>
<script src="LectureNote_files/libs/quarto-html/quarto.js"></script>
<script src="LectureNote_files/libs/quarto-html/popper.min.js"></script>
<script src="LectureNote_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="LectureNote_files/libs/quarto-html/anchor.min.js"></script>
<link href="LectureNote_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="LectureNote_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="LectureNote_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="LectureNote_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="LectureNote_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="데이터-전문가를-위한-실용적인-도커-머신러닝을-위한-케글-수준의-분석-환경-구축" class="level1">
<h1>데이터 전문가를 위한 실용적인 도커: 머신러닝을 위한 케글 수준의 분석 환경 구축</h1>
<section id="goals" class="level2">
<h2 class="anchored" data-anchor-id="goals">Goals</h2>
<ul>
<li>우리는 Hello World 프로젝트가 아닌 데이터 전문가에게 필요한 실제적이고 실용적인 지식에 초점을 맞춥니다.</li>
<li>우리의 목표는 모든 도커 명령어를 외우는 것이 아닙니다. 대신 10개 정도의 핵심 도커 명령어를 깊이 있게 이해하고, 실제 환경에서 어떻게 활용하는지에 중점을 둡니다. 고기를 잡아 주는 것보다 고기 잡는 방법을 가르치는 것이 더 중요합니다.</li>
<li>데이터 전문가로서 필요한 클라우드에 대한 실제적인 기반을 다집니다.</li>
</ul>
</section>
<section id="pre-requisites" class="level2">
<h2 class="anchored" data-anchor-id="pre-requisites">Pre-Requisites</h2>
<ul>
<li>로컬 환경에 Visual Studio Code 설치를 부탁 드립니다. (추가 설치 Extention: vscode-pdf, Draw.io Integration)</li>
<li>깃허브 가입 (깃에 대한 지식 불필요. 가입만 요청 드립니다.)</li>
<li>파이썬, R 등의 경험이 있으면 도움이 되지만 꼭 필요한 것은 아닙니다.</li>
</ul>
</section>
<section id="projects" class="level2">
<h2 class="anchored" data-anchor-id="projects">Projects</h2>
<ul>
<li>클라우드에서 도커를 사용한 케글 수준의 분석 환경 구축 (Ubuntu Image, VSCode for Python, RStudio Sever for R)</li>
<li>클라우드와 로컬 환경의 연결</li>
<li>(Optional) 윈도우즈 로컬 환경에서 도커를 사용한 케글 수준의 분석 환경 구축 (nvidia gpu)</li>
</ul>
</section>
<section id="techskills-you-will-get" class="level2">
<h2 class="anchored" data-anchor-id="techskills-you-will-get">TechSkills You will get</h2>
<ul>
<li>Docker 설치 (Windows, Linux, MAC)와 GPU 셋팅</li>
<li>다양한 도커 커맨드</li>
<li>다양한 리눅스 커맨드</li>
<li>클라우드 서비스 (Azure, AWS), 가상머신</li>
</ul>
</section>
<section id="requests-from-the-instructor" class="level2">
<h2 class="anchored" data-anchor-id="requests-from-the-instructor">Requests from the Instructor</h2>
<ul>
<li>일방적인 수업이 아닌 양방향의 수업을 지향합니다. 게시판에서 질문을 적극적으로 활용하세요. (이해가 되실 때까지 지속적으로 질문을 던지시는 것이 중요합니다. 업무일 기준 2~3일 내에 답변을 드릴 수 있도록 최선을 다하겠습니다.)</li>
<li>다만, 질문이 이해될 수 있도록 (상식 수준에서), 다듬어 주세요.</li>
<li>게시판 공개가 어려운 경우에 메일로 연락주시길 요청 드립니다. (daniel@datatrain.education)</li>
<li>수업을 빠르게 한 번 쭉 들으신 후에, 한 번 더 학습하실 것을 권장드립니다.</li>
</ul>
</section>
<section id="steps" class="level2">
<h2 class="anchored" data-anchor-id="steps">Steps</h2>
<section id="module-00---프로젝트의-소개" class="level3">
<h3 class="anchored" data-anchor-id="module-00---프로젝트의-소개"><a href="./CourseOverview.drawio">Module 00 - 프로젝트의 소개</a></h3>
</section>
<section id="module-01---문제의-정의" class="level3">
<h3 class="anchored" data-anchor-id="module-01---문제의-정의"><a href="./">Module 01 - 문제의 정의</a></h3>
<ul>
<li>데브옵스 (DevOps: Dev + Ops)</li>
<li>서버관리</li>
</ul>
</section>
<section id="module-02---도커의-세가지-주요-목표와-workflow" class="level3">
<h3 class="anchored" data-anchor-id="module-02---도커의-세가지-주요-목표와-workflow"><a href="./Presentation/DockerArchitecture/DOCKER%20ARCHITECTURE%20OVERVIEW.pdf">Module 02 - 도커의 세가지 주요 목표와 WORKFLOW</a></h3>
<pre><code>. Portability (이동성): docker pull
. Reproducibility (재현성): docker build
. Containerization (가상화): docker run</code></pre>
<ul>
<li>Dockefile (붕어빵 틀 설계도) ➡️ Image (붕어빵 틀) ➡️ Container (붕어빵) <a href="./Presentation/DockerArchitecture/붕어빵.pdf">링크</a> ### Module 03 - 도커 설치 가이드</li>
<li><a href="https://docs.docker.com/desktop/install/windows-install/">Windows 10 &amp; 11</a>
<ul>
<li>Windows Powershell 관리자 계정 실행 –&gt; wsl –install</li>
<li>Docker Desktop for Windows 다운로드 이후 설치<br>
</li>
</ul></li>
<li><a href="https://docs.docker.com/engine/install/ubuntu/">Linux, Ubuntu</a></li>
<li>클라우드 실습: <a href="https://1drv.ms/w/s!AoSkNRaAbRTkiItYKP0_DGQSK2J6Cw?e=FSSmyZ">MAC</a> (in AWS)
<ul>
<li>무조건 dedicated host ip를 사용해야 함.</li>
<li>dedicated host ip는 최소 보유 시간이 24시간</li>
<li>MAC 가상 머신은 Spot Discount 사용 옵션 불가 (Spot Discount는 모듈 06에서 자세히 설명)</li>
<li>Windows/Linux 가상 머신 비용 (한 달 10 달러 내외) vs.&nbsp;asw MAC 가상 머신 비용 (생성하는 순간 최소 40 달러)</li>
</ul></li>
</ul>
</section>
<section id="module-04---도커-명령어를-익히기-위한-2가지-기본원리" class="level3">
<h3 class="anchored" data-anchor-id="module-04---도커-명령어를-익히기-위한-2가지-기본원리"><a href="./Presentation/DockerIsEasy/TwoStragegytolearnDockerCommand.pdf">Module 04 - 도커 명령어를 익히기 위한 2가지 기본원리</a></h3>
<ul>
<li>docker –help &amp; <a href="https://docs.docker.com/get-started/docker_cheatsheet.pdf">cheat sheet</a></li>
<li>LLM에게 질문하기</li>
</ul>
</section>
<section id="module-05---도커-가상화에-대한-이해" class="level3">
<h3 class="anchored" data-anchor-id="module-05---도커-가상화에-대한-이해">Module 05 - 도커 가상화에 대한 이해</h3>
<ul>
<li><a href="https://www.docker.com/resources/what-container/">도커의 기원 (What is Docker?)</a>
<ul>
<li>Standard</li>
<li>Lightweight ➡️ do not require an OS per application</li>
<li>Secure<br>
</li>
<li>Linux Native</li>
</ul></li>
<li><a href="https://www.docker.com/blog/containers-and-vms-together/">도커와 가상머신</a>
<ul>
<li>가상머신은 OS를 컨테이너화</li>
<li>도커는 Application을 컨테이너화</li>
<li><a href="https://docs.docker.com/desktop/install/mac-install/">윈도우즈와 맥에서 도커의 적용</a></li>
</ul></li>
<li>도커에 대한 오해와 정정</li>
</ul>
</section>
<section id="module-06---azure에서-ubuntu-가상-머신-구축하기" class="level3">
<h3 class="anchored" data-anchor-id="module-06---azure에서-ubuntu-가상-머신-구축하기"><a href="./Presentation/VMSetting/Cloud%20VM%20GPU%20Setting.pdf">Module 06 - Azure에서 Ubuntu 가상 머신 구축하기</a></h3>
<ul>
<li><a href="./command/docker_installation.txt">Installation Commands</a></li>
<li>로컬 환경과 가상 머신의 연결 -1
<ul>
<li>ssh (Secure Shell)을 이용한 터미널 방식의 연결</li>
<li>RDP (Remote Desktop Protocol)을 이용한 GUI 방식의 연결
<ul>
<li><a href="https://learn.microsoft.com/en-us/azure/virtual-machines/linux/use-remote-desktop?tabs=azure-cli">vm Setting</a></li>
<li>Windows 로컬 환경에서 연결</li>
<li><a href="./Presentation/VMSetting/Connect%20between%20Locan%20and%20VM.pdf">로컬 환경이 Windows가 아닌 경우</a></li>
</ul></li>
</ul></li>
<li>Chrome 설치
<ul>
<li>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb<br>
</li>
<li>sudo dpkg -i google-chrome-stable_current_amd64.deb<br>
</li>
<li>sudo apt-get install -f</li>
</ul></li>
<li><a href="https://code.visualstudio.com/docs/setup/linux">Visual Studio Code 설치</a>
<ul>
<li>Dev Container Extension 설치: both in vm and local</li>
<li>Remote Tunnel Extension 설치: both in vm and local</li>
</ul></li>
<li>로컬 환경과 가상 머신의 연결 -2
<ul>
<li>Remote Tunnel 방식을 이용한 연결
<ul>
<li>Turn On Remote Tunnel Access… (vm): only once</li>
<li>Install as a service Run (vm): only once</li>
<li>sign in with github (vm): only once –&gt; 가상머신 Rebooting</li>
<li>ssh connect to vm from local ➡️ always</li>
<li>Connect to Tunnel… (local) ➡️ always</li>
<li>sign in with github (local): ➡️ always</li>
<li>select the vm (local) ➡️ always</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="module-07---파이썬을-위한-도커" class="level3">
<h3 class="anchored" data-anchor-id="module-07---파이썬을-위한-도커">Module 07 - 파이썬을 위한 도커</h3>
<ul>
<li><p>베이스 이미지를 가져오기 위한 도커 명령어:<br>
docker pull &lt; python gpu base image name:tag &gt;</p></li>
<li><p><a href="./Kaggle-Python-GPU/DockerFile">파이썬 도커 환경을 위한 도커 파일</a></p></li>
<li><p>비주얼 스튜디오에서 파이썬 도커 환경 연결하기<br>
1) Add Dev Container Configuration Files…<br>
2) From ‘Dockerfile’</p></li>
<li><p><a href="./Kaggle-Python-GPU/devcontainer_example.json">추가 설정</a></p></li>
<li><p>Speed Benchmark</p>
<ul>
<li>Local Machine: Intel(R) Core(TM) i7-1070CF CPU 8 Cores, 16 GB Physical Memory, NVIDIA GeForce RTX 3070 GPU</li>
<li>Virtual Machine: AMD EPYC 7V12 64-Core Processor, 28 GB Physical Memory, NVIDIA Tesla T4 GPU</li>
</ul></li>
</ul>
<table class="table">
<thead>
<tr class="header">
<th>Model &nbsp;Type</th>
<th>CPU</th>
<th>GPU</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Local Machine</td>
<td>2s 5ms/stepsec</td>
<td>2s 6ms/step</td>
</tr>
<tr class="even">
<td>Virtual Machine</td>
<td>1s 3ms/step</td>
<td>1s 2ms/step</td>
</tr>
</tbody>
</table>
</section>
<section id="module-08---r을-위한-도커" class="level3">
<h3 class="anchored" data-anchor-id="module-08---r을-위한-도커">Module 08 - R을 위한 도커</h3>
<ul>
<li>베이스 이미지를 가져오기 위한 도커 명령어:<br>
docker pull &lt; r gpu base image name:tag&gt;<br>
</li>
<li>Kaggle-gpu 이미지로부터 생성된 R 컨테이너를 RStudio Server IDE 환경에서 실행시키기 위한 도커 명령어:<br>
docker run -d -p 8787:8787 –gpus all -v “&lt; local path &gt;:&lt; container path &gt;” –name &lt; container name &gt; &lt; image name &gt; /bin/bash -c “rstudio-server start &amp;&amp; tail -f /dev/null”<br>
cf) docker run -p 8888:8888 –gpus all -v “&lt; local path &gt;:&lt; container path &gt;” –name &lt; container name &gt; &lt; image name &gt;<br>
</li>
<li>Port에 대한 이해</li>
<li><a href="https://github.com/Kaggle/docker-rstats/blob/main/Dockerfile">CMD/ENTRYPOINT에 대한 이해</a></li>
<li><a href="https://blogs.rstudio.com/ai/posts/2020-09-29-introducing-torch-for-r/">torch</a> gpu 버전 확인<br>
library(torch)<br>
torch_tensor(1, device = “cuda”)<br>
</li>
<li><a href="./Presentation/PythonBackend/HOW%20WORK%20KERAS%20in%20R.pdf">Keras를 실행하기 위한 Python Backend의 이해</a>
<ul>
<li>Python 설치 경로 확인
<ul>
<li>docker exec -it &lt; container name &gt; R<br>
library(reticulate)<br>
py_config()</li>
<li>in RStudio<br>
library(reticulate)<br>
py_config()</li>
</ul></li>
</ul></li>
<li>docker build
<ul>
<li><a href="./makeBetterImage.drawio">실습구조</a></li>
<li><a href="https://posit.co/download/rstudio-server/">최신 RStudio Server 설치</a> (메모리 사용량 모니터링)<br>
</li>
<li><a href="./Kaggle-R-GPU/setup.R">setup.R</a> (RStudio에서 접근 가능한 디렉토리에 python과 keras 설치)</li>
<li><a href="./Kaggle-R-GPU/Dockerfile">R 도커 환경을 위한 도커 파일</a></li>
<li>Image 생성 docker build –build-arg &lt;변수명&gt;=&lt;값&gt; -t &lt; image name&gt; .</li>
</ul></li>
<li>docker push from LM
<ul>
<li>docker login<br>
</li>
<li>docker tag your-image:version registry(username@dockerhub)/your-image:version</li>
<li>docker push yourusername/your-repository:version</li>
</ul></li>
<li>docker pull from VM
<ul>
<li>docker pull yourusername/your-repository:version</li>
</ul></li>
</ul>
</section>
<section id="module-09---개발-환경-내의-도커-vs-도커-내의-개발-환경" class="level3">
<h3 class="anchored" data-anchor-id="module-09---개발-환경-내의-도커-vs-도커-내의-개발-환경">Module 09 - 개발 환경 내의 도커 VS 도커 내의 개발 환경</h3>
<ul>
<li><a href="./Presentation/ExternalContainer_InternalContainer/Inside%20VS%20Outside.pdf">Visual Studio Code 방식과 RStudio 방식의 비교</a></li>
</ul>
</section>
<section id="module-10---원격-연결-마스터하기-vscode-vs.-jupyter-server-vs.-rstudio-server" class="level3">
<h3 class="anchored" data-anchor-id="module-10---원격-연결-마스터하기-vscode-vs.-jupyter-server-vs.-rstudio-server"><a href="./Presentation/ConnectWithoutRDP/CONNECT%20WITHOUT%20RDP.pdf">Module 10 - 원격 연결 마스터하기: VSCode vs.&nbsp;Jupyter Server vs.&nbsp;RStudio Server</a></h3>
<ul>
<li>VSCode</li>
<li>Jupyter Server</li>
<li>RStudio</li>
</ul>
</section>
<section id="module-11---파일-공유-시스템-설정" class="level3">
<h3 class="anchored" data-anchor-id="module-11---파일-공유-시스템-설정"><a href="https://1drv.ms/w/s!AoSkNRaAbRTkiItGeimXLeA9hiOEzg?e=eeXFES">Module 11 - 파일 공유 시스템 설정</a></h3>
<ul>
<li>ADLS2 (Azure Data Lake Storage Generation 2) 생성</li>
<li>ADLS2 Mount in Ubuntu (Linux)</li>
<li>ADLS2 Mount 방식을 사용하는 이유 <a href="https://learn.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-access-control-model?wt.mc_id=searchAPI_azureportal_inproduct_rmskilling&amp;sessionId=416f578211824749b3736e7d6ad23833">Granual Access Control: 링크1</a> &amp; <a href="https://learn.microsoft.com/en-us/credentials/certifications/identity-and-access-administrator/?source=recommendations">Certification for Access Control: 링크2</a><br>
</li>
<li>ADLS2 Mount in Windows</li>
<li>Microsoft Azure Storage Explorer를 이용한 ADLS2 Access (Windows &amp; Linux &amp; MAC)</li>
<li>ADLS2 Mount 방식과 Azure Storage Explorer 방식이 가지는 제한사항</li>
<li><a href="./CourseOverview_includingFileSharing.drawio">파일 공유 시스템의 실용적인 설정</a></li>
</ul>
<!-- - [blobfuse2 설치](https://learn.microsoft.com/en-us/azure/storage/blobs/blobfuse2-how-to-deploy?tabs=Ubuntu)
- [Mount](https://learn.microsoft.com/en-us/azure/storage/blobs/blobfuse2-how-to-deploy?tabs=Ubuntu#how-to-mount-a-blob-container)
- [config.yaml](./ADLS2Mount/blobfuse/config.yaml)
- get the container key information  
        curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash    
        az login az storage account keys list --account-name YOUR_STORAGE_ACCOUNT_NAME --resource-group YOUR_RESOURCE_GROUP_NAM   -->
</section>
<section id="module-12---공동-작업을-위한-setting" class="level3">
<h3 class="anchored" data-anchor-id="module-12---공동-작업을-위한-setting"><a href="https://1drv.ms/w/s!AoSkNRaAbRTkiItNB1fc_cs6N11i_g?e=khCIAD">Module 12 - 공동 작업을 위한 Setting</a></h3>
<ul>
<li>새 사용자 (팀원) Account 생성 by admin</li>
<li>접근 권한 부여 by admin
<ul>
<li>gui 방식을 이용한 VM 접근</li>
<li>ssh 엑세스 키 생성</li>
</ul></li>
<li>Tunnel 방식을 통한 연결 by user</li>
<li>진정한 Virtualization 구현</li>
<li>VM과 Blob Storage 접근 권한 재설정</li>
</ul>
</section>
<section id="module-13-optional---윈도우즈에-gpu-환경-구성하기" class="level3">
<h3 class="anchored" data-anchor-id="module-13-optional---윈도우즈에-gpu-환경-구성하기"><a href="./Presentation/LMSetting/Windows%20GPU.pdf">Module 13 (Optional) - 윈도우즈에 GPU 환경 구성하기</a></h3>
<ul>
<li>Docker Install in Windows</li>
<li>Nvidia GPU driver Install in Windows
<ul>
<li><a href="https://www.google.com/search?q=nvidia+gpu+driver+install+wsl+The+CUDA+driver+installed+on+Windows+host+will+be+stubbed+inside+the+WSL+2+as+libcuda.so&amp;newwindow=1&amp;sca_esv=591711254&amp;sxsrf=AM9HkKkJtM1gNvF5wvkJv8itArMjoo1QpQ%3A1702845460276&amp;ei=FFx_ZZ-kENyH9u8P7MWq0Aw&amp;ved=0ahUKEwif_pDWqZeDAxXcg_0HHeyiCsoQ4dUDCBA&amp;uact=5&amp;oq=nvidia+gpu+driver+install+wsl+The+CUDA+driver+installed+on+Windows+host+will+be+stubbed+inside+the+WSL+2+as+libcuda.so&amp;gs_lp=Egxnd3Mtd2l6LXNlcnAidm52aWRpYSBncHUgZHJpdmVyIGluc3RhbGwgd3NsIFRoZSBDVURBIGRyaXZlciBpbnN0YWxsZWQgb24gV2luZG93cyBob3N0IHdpbGwgYmUgc3R1YmJlZCBpbnNpZGUgdGhlIFdTTCAyIGFzIGxpYmN1ZGEuc28yBRAhGKABMgUQIRigATIFECEYoAEyBRAhGKABMgUQIRigATIIECEYFhgeGB1I3A9QmQNYugVwAXgBkAEAmAGgAaABoAGqAQMwLjG4AQPIAQD4AQH4AQLCAgoQABhHGNYEGLAD4gMEGAAgQYgGAZAGCA&amp;sclient=gws-wiz-serp">Theroy</a></li>
<li><a href="https://www.nvidia.com/Download/index.aspx">Download Link</a></li>
</ul></li>
<li>Nvidia Container Toolkit Install in WSL2
<ul>
<li><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html">Reference</a></li>
<li><a href="./command/ContainerToolkit_installation_Windows.txt">Scripts</a></li>
</ul></li>
</ul>
</section>
<section id="스스로-공부해-볼-만한-주제들" class="level3">
<h3 class="anchored" data-anchor-id="스스로-공부해-볼-만한-주제들">스스로 공부해 볼 만한 주제들</h3>
<ul>
<li>Kaggle 이미지로부터 가벼운 이미지 만들기 또는 패키지 추가하기 (클라우드 가격 정책의 이해)</li>
<li>주식 데이터 Web App 구현</li>
</ul>
</section>
<section id="디스커션---python-vs.-r" class="level3">
<h3 class="anchored" data-anchor-id="디스커션---python-vs.-r">디스커션 - Python vs.&nbsp;R</h3>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>